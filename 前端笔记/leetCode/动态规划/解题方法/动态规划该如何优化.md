# 动态规划该如何优化？

原文转载自 [动态规划该如何优化](https://mp.weixin.qq.com/s/FA5lyv2VnsP4XM0wUz0JlQ)



### 优化核心：画图！画图！画图

没错，80% 的动态规划题都可以画图，其中 80% 的题都可以通过画图一下子知道怎么优化，当然，DP 也有一些很难的题，想优化可没那么容易，不过，今天我要讲的，是属于不怎么难，且最常见，面试笔试最经常考的难度的题。

下面我们直接通过三道题目来讲解优化，你会发现，这些题，优化过后，代码只有细微的改变，你只要会一两道，可以说是会了 80% 的题。



### O(n*m) 空间复杂度优化成 O(n)

上次那个青蛙跳台阶的 dp 题是可以把空间复杂度 O( n) 优化成 O(1)，本来打算从这道题讲起的，但想了下，想要学习 dp 优化的感觉至少都是 **小小大佬**了，所以就不讲了，就从二维数组的 dp 讲起。



### 案例1：最多路径数

#### 问题描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

> 这道题的 dp 转移公式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]，代码如下

```js
function uniquePaths( m, n) {
   if (m <= 0 || n <= 0) {
     return 0;
   }
   let dp = Array.from({length: m}, () => new Array(n).fill(0));
   // 初始化
   for(int i = 0; i < m; i++){
     dp[i][0] = 1;
   }
   for(int i = 0; i < n; i++){
     dp[0][i] = 1;
   }
   // 推导出 dp[m-1][n-1]
   for (int i = 1; i < m; i++) {
     for (int j = 1; j < n; j++) {
       dp[i][j] = dp[i-1][j] + dp[i][j-1];
     }
   }
   return dp[m-1][n-1];
}
```



