# Node js

Node.js 的[官方文档](https://nodejs.org/en/)中对 Node.js 的说明是：

> Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.

Node 是一个服务器端 JavaScript 解释器，用于方便地搭建响应速度快、易于扩展的**网络应用**。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。  Node.js 是一个可以让 JavaScript 运行在浏览器之外的平台。**它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能**。历史上将 JavaScript移植到浏览器外的计划不止一个，但Node.js 是最出色的一个。



## Node.js的作用

Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。我们来看一个简单的例子，在 Java™ 和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。所以在传统的后台开发中，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：**服务器能够处理的并发连接的最大数量**。这个不同的架构承载的并发数量是不一致的。  

而Node的出现就是为了解决这个问题：更改连接到服务器的方式。在Node 声称它不允许使用锁，它不会直接阻塞 I/O 调用。Node在每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。



## Node.js能做什么

借用一句经典的描述Node.js的话:正如 JavaScript 为客户端而生，Node.js 为网络而生。  使用Node.js，你可以轻易的实现：

- 具有复杂逻辑的网站；
- 基于社交网络的大规模 Web 应用；
- Web Socket 服务器；
- TCP/UDP 套接字应用程序；
- 命令行工具；
- 交互式终端程序；
- 带有图形用户界面的本地应用程序；
- 单元测试工具；
- 客户端 JavaScript 编译器。



Node 的结构和Chrome 非常相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件来服务I/O。



Node 的特点

- 异步I/O

- 事件与回调函数
- 单线程



### 单线程

单线程最大的好处是不用像多线程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。

单线程的缺点：

- 无法利用多核CPU
- 错误会引起整个应用的退出
- 大量计算占用CPU导致无法继续调用异步IO

像􏳩􏳪􏰩中JavaScript与UI􏴊用一个线程一样，JavaScript􏶤时􏵃􏱬􏲰会􏳥􏶈UI的􏶥􏶦􏰯􏵗应 􏱓中􏶧。在Node中，􏶤时􏵃的CPU􏶣用也会􏳥􏶈后续的􏴼􏰏I/O发不􏱾􏴽用，已􏴹􏱎的􏴼􏰏I/O的 􏵯􏴽􏵰数也会􏰸不到􏵋时􏱬􏲰。



Web Workers能􏳒创􏰦工作线程􏲤􏲯􏲰􏰼􏰽，以 解决JavaScript大􏰼􏰽􏲶􏲷UI􏶥􏶦的问题。工作线程为了不􏲶􏲷􏱹线程，􏴘过􏶰􏶱􏵲􏵳的􏱱􏱽􏲤 􏵲􏵳􏶮􏲰􏳅􏶬，这也使􏰸工作线程不能􏶲问到􏱹线程中的UI。

Node􏶳用了与Web Workers相同􏴻的思路来􏵺􏵻􏲤解决单􏲽线程中大􏰼􏰽量计算的问题􏲈child_process。

􏵞􏲯子进程的出现􏱾􏳄，意味􏱜􏶴着Node可以从􏴛􏲢应对􏲽线程在􏶠􏶡性􏰯􏵄􏲌􏶙用多􏶛CPU􏱱􏲟的问 题。􏴘过􏰍􏰼􏰽分发到􏵬个􏵞􏲯程，可以􏰍大量􏰼􏰽分解􏶵，􏳹后􏶶􏴘过􏲯程之􏵃的事􏲵􏶰􏶱􏲤 􏵲􏵳􏳅􏶬，这可以很好􏲢􏶌􏱋应用􏱲􏴐的􏲚􏲽􏰯􏳝􏶷􏶸。􏴘过Master-Worker的管􏱦􏱱􏱽，也可以 很好􏲢管􏱦􏵬个工作􏲯程，以􏱴到􏲹高的􏶠􏶡性。





# Node.js运行原理分析

应用程序的请求过程可以分为俩个部分**：CPU运算和I/O读写**

CPU计算速度通常远高于磁盘读写速度，这就导致CPU运算已经完成，但是不得不等待磁盘I/O任务完成之后再继续接下来的业务。  所**以I/O才是应用程序的瓶颈所在**，在I/O密集型业务中，假设请求需要100ms来完成，其中99ms化在I/O上。如果需要优化应用程序，让他能同时处理更多的请求，我们会采用多线程，同时开启100个、1000个线程来提高我们请求处理，当然这也是一种可观的方案。       **但是由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源。**但操作系统在内核切换线程的同时也要切换线程的上线文，当线程数量过多时，**时间将会被消耗在上下文切换中**。所以在大并发时，多线程结构还是无法做到强大的伸缩性。   

那么是否可以另辟蹊径呢？！我们先来看看单线程，《深入浅出Node》一书提到 **“单线程的最大好处，是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文切换所带来的性能上的开销”**，那么一个线程一次只能处理一个请求岂不是无稽之谈，先让我们看张图： 

![5h9hlnfcfv](https://tva1.sinaimg.cn/large/007S8ZIlgy1gg4nl4q336j30go0bvglv.jpg)

Node.js的单线程并不是真正的单线程，只是开启了单个线程进行业务处理（cpu的运算），同时开启了其他线程专门处理I/O。当一个指令到达主线程，主线程发现有I/O之后，直接把这个事件传给I/O线程，不会等待I/O结束后，再去处理下面的业务，而是拿到一个状态后立即往下走，这就是“单线程”、“异步I/O”。   I/O操作完之后呢？Node.js的I/O 处理完之后会有一个回调事件，这个事件会放在一个事件处理队列里头，在进程启动时node会创建一个类似于While(true)的循环，它的每一次轮询都会去查看是否有事件需要处理，是否有事件关联的回调函数需要处理，如果有就处理，然后加入下一个轮询，如果没有就退出进程，这就是所谓的“事件驱动”。这也从Node的角度解释了什么是”事件驱动”。 