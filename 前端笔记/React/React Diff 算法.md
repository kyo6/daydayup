## React Diff 算法

Diff算法有个很重要的概念：同级比较。

![img](https://img2018.cnblogs.com/blog/1633907/201907/1633907-20190722175707538-1823672080.png)

首先会比较最顶层的虚拟DOM节点是否一致，如果一致的话，就继续比较下一层的节点；如果不一致的话，react就会把这个节点及其下面所有节点全部删掉，重新生成一遍新的DOM，然后用新的DOM替换原始页面的DOM。有人可能会说，这样性能不是会很低吗？如果除了这个最顶层节点不一致，下面都是一致的，这样整个替换，不会很浪费性能吗？其实，虽然可能会造成DOM重新渲染性能上的浪费，但比对的算法简单，由此比对速度也会很快，大大减少了比对算法上的性能消耗，所以采用同级比较的算法。





同级元素位置发生变化

- 比对不同类型的元素

  当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。当拆卸一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 `componentWillUnmount()` 方法。当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 `componentWillMount()` 方法，紧接着 `componentDidMount()` 方法。所有跟之前的树所关联的 state 也会被销毁。

- 对比同一类型的元素

  当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。比如：

- 对比同类型的组件元素

  当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 `componentWillReceiveProps()` 和 `componentWillUpdate()` 方法。

### Keys

为了解决以上问题，React 支持 `key` 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 `key` 之后使得之前的低效转换变得高效







- React更新阶段会对ReactElement类型判断而进行不同的操作；ReactElement类型包含三种即：文本、Dom、组件；
- 每个类型的元素更新处理方式：
  - 自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。
  - text节点的更新很简单，直接更新文案。
  - 浏览器基本元素的更新，分为两块：
    1. 更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。
    2. 子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新,这样也会递归查找差异对象。不可直接更新的删除之前的对象或添加新的对象。之后根据差异对象操作dom元素（位置变动，删除，添加等）。